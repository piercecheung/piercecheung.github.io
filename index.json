[{"content":"Recently I made a dicision to pursue Cloud Native Stack and start to developing on Kubernetes Clusters for my projects. So I started to learn how to setup a Kubernetes Cluster for developing purpose on Oracle Cloud Infrastructure (OCI) from scratch. The reason why I choose OCI is it\u0026rsquo;s has a free tier and I just need to setup a cluster on it for development and testing.\nAnd also I want to do Kubernetes in a more hands-on way, so I choose to use kubeadm to setup the cluster, from scratch.\nHere are the steps.\nüìù Note: This series of articles is intend to have a hands-on experience on Kubernetes, so I will not go into details of the concepts of Kubernetes. If you want to know more about Kubernetes, please refer to the Kubernetes official documentation.\nPart 1: Setup a Kubernetes Cluster Control Plane on OCI Plan and preparations According to the Kubernetes official documentation, the minimum requirements for a Kubernetes cluster are:\nA compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions based on Debian and Red Hat, and those distributions without a package manager. 2 GB or more of RAM per machine (any less will leave little room for your apps). 2 CPUs or more. Full network connectivity between all machines in the cluster (public or private network is fine). Unique hostname, MAC address, and product_uuid for every node. See here for more details. Certain ports are open on your machines. See here for more details. Swap disabled. You MUST disable swap in order for the kubelet to work properly. So we will use a VM instance with 2 OCPU and 8 GB RAM on OCI to setup the Kubernetes cluster\u0026rsquo;s control plane (master node).\nOpen Ports in iptables For a virtual machine instance on OCI, all the requirements are met except the network connectivity part, as in the OCI platform the virtual machine is using iptables not the normal ufw firewall to control the network traffic. So we need to make some changes to the iptables rules to make the network traffic work properly.\nAccording to the Kubernetes official documentation, the following ports are required to be open for the control plane:\nProtocol Direction Port Range Purpose Used By TCP Inbound 6443* Kubernetes API server All TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 10259 kube-scheduler Self TCP Inbound 10257 kube-controller-manager Self After we have created a virtual machine instance on OCI, we can use the following commands to open the required ports:\nsudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 6443 -j ACCEPT sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 2379:2380 -j ACCEPT sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 10250 -j ACCEPT sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 10259 -j ACCEPT sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 10257 -j ACCEPT To make the changes permanent:\nsudo netfilter-persistent save We can also use the following command to check the status of the iptables rules:\nsudo iptables -L The following is the output of the command related our changes:\nACCEPT tcp -- anywhere anywhere state NEW tcp dpt:10257 ACCEPT tcp -- anywhere anywhere state NEW tcp dpt:10259 ACCEPT tcp -- anywhere anywhere state NEW tcp dpt:10250 ACCEPT tcp -- anywhere anywhere state NEW tcp dpts:2379:2380 ACCEPT tcp -- anywhere anywhere state NEW tcp dpt:6443 Add Ingress Rules in the Security List of VCN The last step is to config the Ingress Rulls in the Security List of the virtual machine\u0026rsquo;s VCN. We can follow the OCI official documentation to do that. We need to add the following rules:\nStateless Source IP Protocal Source Port Range Destination Port Range Allows Description No 0.0.0.0/0 TCP All 6443 TCP traffic for ports: 6443 Kubernetes API server Install Container Runtime Refer the Kubernetes official documentation, there are several container runtimes that can be used with Kubernetes, including Docker, containerd, CRI-O, we choose to use containerd as the container runtime.\nInstall and config prerequisites Forwarding IPv4 and letting iptables see bridged traffic Execute the following commands to let br_netfilter and overlay modules to be loaded:\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # sysctl params required by setup, params persist across reboots cat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF # Apply sysctl params without reboot sudo sysctl --system Verify that the br_netfilter, overlay modules are loaded by running below instructions:\nlsmod | grep br_netfilter lsmod | grep overlay Verify that the net.bridge.bridge-nf-call-iptables, net.bridge.bridge-nf-call-ip6tables, net.ipv4.ip_forward system variables are set to 1 in the sysctl config by running below instruction:\nsysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward Install containerd The installation steps are from the containerd official documentation.\nFirst of all, Download the containerd-\u0026lt;VERSION\u0026gt;-\u0026lt;OS\u0026gt;-\u0026lt;ARCH\u0026gt;.tar.gz archive from here.\nFor example if we are using Ubuntu 20.04 on arm64, we need to download the containerd-1.6.15-linux-arm64.tar.gz archive.\nsudo wget https://github.com/containerd/containerd/releases/download/v1.6.15/containerd-1.6.15-linux-arm64.tar.gz sudo tar Cxzvf /usr/local containerd-1.6.15-linux-arm64.tar.gz sudo wget https://raw.githubusercontent.com/containerd/containerd/main/containerd.service sudo cp containerd.service /usr/local/lib/systemd/system/ sudo systemctl daemon-reload sudo systemctl enable --now containerd Confirm the service via:\nsudo systemctl status containerd Install runc Download the runc.\u0026lt;ARCH\u0026gt; binary from here.\nFor example we are using Ubuntu 20.04 on arm64, so we need to download the runc.arm64 binary.\nsudo wget https://github.com/opencontainers/runc/releases/download/v1.1.4/runc.arm64 sudo install -m 755 runc.arm64 /usr/local/sbin/runc Install CNI plugins sudo wget https://github.com/containernetworking/plugins/releases/download/v1.2.0/cni-plugins-linux-arm64-v1.2.0.tgz sudo mkdir -p /opt/cni/bin sudo tar Cxzvf /opt/cni/bin cni-plugins-linux-arm64-v1.2.0.tgz Setup containerd for Kubernetes # Create the containerd config file directory sudo mkdir -p /etc/containerd # Create the containerd config file sudo su containerd config default \u0026gt; /etc/containerd/config.toml exit Edit the /etc/containerd/config.toml file and set the SystemdCgroup to true:\n[plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.runtimes.runc] ... [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.runtimes.runc.options] SystemdCgroup = true Restart the containerd service:\nsudo systemctl restart containerd Install kubeadm Refer the Kubernetes official documentation, install kubeadm, kubelet and kubectl.\nsudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl sudo curl -fsSLo /etc/apt/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg sudo echo \u0026#34;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl sudo apt-mark hold kubelet kubeadm kubectl üìù Note: According to Kubernetes official documentation, the cgroup driver used by kubelet must match the container runtime and kubelet. But for kubernetes version higher than 1.22, if not setting cgroupDriver in kubeletconfiguration field, then systemd will be set, so no need to edit the kubeadm-config.yaml. This can be verified with sudo nano /var/lib/kubelet/config.yaml that cgroupDriver has been already set to systemd.\nExecute the following command to check the cgroup driver used by kubelet:\nnano /var/lib/kubelet/config.yaml We can find that the cgroupDriver has been already set to systemd:\napiVersion: kubelet.config.k8s.io/v1beta1 ... cgroupDriver: systemd Initialize the master node with config file Some config need to be setup before initializing the master node:\nclusterName: the name of the cluster podSubnet: the subnet used by pods certSANs: the IP address or DNS need to be added to the api server certificate So let us create an init-config.yaml file with the following content:\napiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration networking: podSubnet: \u0026#34;192.168.0.0/16\u0026#34; apiServer: certSANs: - \u0026#34;myapiserverip or myapiserverdns\u0026#34; clusterName: \u0026#34;myclustername\u0026#34; Then use the kubeadm init command with the --config flag to initialize the master node:\nsudo kubeadm init --config init-config.yaml After the initialization, the output will show the command to join the worker nodes to the cluster:\nYour Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a Pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: /docs/concepts/cluster-administration/addons/ You can now join any number of machines by running the following on each node as root: kubeadm join \u0026lt;control-plane-host\u0026gt;:\u0026lt;control-plane-port\u0026gt; --token \u0026lt;token\u0026gt; --discovery-token-ca-cert-hash sha256:\u0026lt;hash\u0026gt; As intructed in the output, run the following commands to setup the kubeconfig:\nmkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Now we can using kubectl to manage the cluster from the master node:\nkubectl get nodes Install pod network add-on Refer the Kubernetes official documentation, we must deploy a Container Network Interface (CNI) based Pod network add-on so that the Pods can communicate with each other. Cluster DNS (CoreDNS) will not start up before a network is installed.\nSee a list of add-ons that implement the Kubernetes networking model.\nFor this time we choose calico as the pod network add-on. Execute the following command to install calico:\ncurl https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml -O kubectl apply -f calico.yaml After installing the pod network add-on, we can verify the status of the pods:\nkubectl get pods --all-namespaces Use kubectl on local machine to connect to the cluster As we initialized the master node with the certSANs, we can use the master node\u0026rsquo;s kubeconfig file to connect to the cluster from local machine.\nUsing the following command to get the kubeconfig file from the master node:\nkubectl config view --minify --flatten Copy the content of the output and save it to a file named config in the ~/.kube directory on your local machine (asuume the local machine is a Linux or MacOS machine):\nmkdir -p $HOME/.kube nano $HOME/.kube/config Then we can use the kubectl command to connect to the cluster from local machine:\nkubectl get nodes Next step After all the steps above, we have a kubernetes cluster with one master node. Next setp is to add worker nodes to the cluster.\nWe will continue this part in the next post.\n","permalink":"https://blog.mindsmining.com/posts/how-to-setup-k8s-cluster-on-oci-from-scratch/","summary":"Part 1: Setup a Kubernetes Cluster Control Plane on OCI","title":"Setup a K8S Cluster on OCI from scratch - Part 1"},{"content":"I\u0026rsquo;ve built a website with Flask and Python and it\u0026rsquo;s only published in English. As the website will be mainly visited by people in China and other countries, I want to make the website a multilingual one, at least bilingual: Chinese and English.\nSo I started to build the multilingual website with Flask-Babel. Here are the steps.\nExisting project structure ‚îú‚îÄ‚îÄ venv ‚îÇ¬†‚îú‚îÄ‚îÄ bin ‚îÇ¬†‚îî‚îÄ‚îÄ include ‚îú‚îÄ‚îÄ webapp ‚îÇ¬†‚îú‚îÄ‚îÄ __init__.py ‚îÇ¬†‚îú‚îÄ‚îÄ config.py ‚îÇ¬†‚îú‚îÄ‚îÄ routes.py ‚îÇ¬†‚îú‚îÄ‚îÄ static ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ favicon.ico ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ styles.css ‚îÇ¬†‚îî‚îÄ‚îÄ templates ‚îÇ¬†‚îú‚îÄ‚îÄ about.html ‚îÇ¬†‚îú‚îÄ‚îÄ layout.html ‚îÇ¬†‚îî‚îÄ‚îÄ index.html ‚îú‚îÄ‚îÄ app.py ‚îî‚îÄ‚îÄ requirements.txt Install Flask-Babel The flask extension we need to install is Flask-Babel.\n(venv) $ pip install Flask-Babel Flask-Babel is easy to use, just like others, we need to add the following lines in the __init__.py file to initialize it:\n# ... from flask_babel import Babel app = Flask(__name__) # ... babel = Babel(app) As we are going to translate the website into Chinese, let us add a configuration variable in the config.py file:\nclass Config(object): # ... LANGUAGES = [\u0026#39;en_US\u0026#39;, \u0026#39;zh_CN\u0026#39;] en_US and zh_CN are the language codes of English and Chinese respectively, with the _US and _CN suffixes to indicate the country code. We can use two-letter codes like en and zh as well.\nThe Babel instance has a localeselector function that is called when a request is made to the website and will return the language code of the user\u0026rsquo;s browser. The accept_languages object works with the Accept-Language header in the request that specifies the client language and locale perferences. best_match will return the best matches from the list of available languages.\nIn the __init__.py:\nfrom flask import request # ... @babel.localeselector def get_locale(): return request.accept_languages.best_match(app.config[\u0026#39;LANGUAGES\u0026#39;]) Marking Texts need to be translated Text in the Python Source Code As we have literal strings in the Python source code, like in the flash() statement, we need to mark them as translatable by wrapping them in the _() function. The _() function is a shortcut for gettext().\n# ... flash(\u0026#39;Hello, world!\u0026#39;) # ... Change the flash() statement to:\nfrom flask_babel import _ # from flask_babel import gettext as _ # ... flash(_(\u0026#39;Hello, world!\u0026#39;)) üìù Note: Don\u0026rsquo;t to forget to import the _() function from flask_babel. The _() function is a shortcut for gettext().\nTexts in the Templates For the text in the templates, the _() function is also available so the text can be marked as translatable in the similar way. For example we have a template about.html:\n\u0026lt;h1\u0026gt;About Us\u0026lt;/h1\u0026gt; Change it to:\n\u0026lt;h1\u0026gt;{{ _(\u0026#39;About Us\u0026#39;) }}\u0026lt;/h1\u0026gt; üìù Note: {{ ... }} should be added to enforce the _() function to be called instead of being treated as a literal string.\nExtracting Texts Once all the texts are marked as translatable with _(), we can translate them. As mentioned in the tutorial of Flask-Babel, the way is to use the pybabel to extract the texts from the source code and put them in the messages.pot file.\nFirst of all, we need to have some config, create babel.cfg file next to app.py:\n[python: webapp/**.py] [jinja2: webapp/templates/**.html] extensions=jinja2.ext.autoescape,jinja2.ext.with_ The first two lines should indicate the source files of source code and template html files respectively. The extensions line indicates two extensions provided by the Jinja2 template engine that help Flask-Babel properly parse template files.\nThen extract the texts from the source code and put them in the messages.pot file:\n(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot . extracting messages from webapp/__init__.py (extensions=\u0026#34;jinja2.ext.autoescape,jinja2.ext.with_\u0026#34;) extracting messages from webapp/config.py (extensions=\u0026#34;jinja2.ext.autoescape,jinja2.ext.with_\u0026#34;) extracting messages from webapp/routes.py (extensions=\u0026#34;jinja2.ext.autoescape,jinja2.ext.with_\u0026#34;) writing PO template file to messages.pot üìù Note: The -o option indicates the output file. The -k option indicates the keyword to be used to mark the texts. If we use lazy_gettext() (imported as _l()) to mark the texts, the -k option should be _l. The _() function is by default.\nCreating a language translation Now let\u0026rsquo;s create the language translation for the languages we want to translate to. For this time, we want to translate the website into Chinese:\n(venv) $ pybabel init -i messages.pot -d webapp/translations -l zh creating catalog webapp/translations/zh/LC_MESSAGES/messages.po based on messages.pot üìù Note: The -d option indicates the directory where the translations are stored.\nIf we want to translate to other languages, just repeate the above steps seperately.\nFollowing is the messages.po that are created:\n# Chinese translations for PROJECT. # Copyright (C) 2022 ORGANIZATION # This file is distributed under the same license as the PROJECT project. # FIRST AUTHOR \u0026lt;EMAIL@ADDRESS\u0026gt;, 2022. # msgid \u0026#34;\u0026#34; msgstr \u0026#34;\u0026#34; \u0026#34;Project-Id-Version: PROJECT VERSION\\n\u0026#34; \u0026#34;Report-Msgid-Bugs-To: EMAIL@ADDRESS\\n\u0026#34; \u0026#34;POT-Creation-Date: 2022-04-29 14:30-0700\\n\u0026#34; \u0026#34;PO-Revision-Date: 2022-04-29 14:32-0700\\n\u0026#34; \u0026#34;Last-Translator: FULL NAME \u0026lt;EMAIL@ADDRESS\u0026gt;\\n\u0026#34; \u0026#34;Language: zh\\n\u0026#34; \u0026#34;Language-Team: zh \u0026lt;LL@li.org\u0026gt;\\n\u0026#34; \u0026#34;Plural-Forms: nplurals=1; plural=0;\\n\u0026#34; \u0026#34;MIME-Version: 1.0\\n\u0026#34; \u0026#34;Content-Type: text/plain; charset=utf-8\\n\u0026#34; \u0026#34;Content-Transfer-Encoding: 8bit\\n\u0026#34; \u0026#34;Generated-By: Babel 2.10.1\\n\u0026#34; #: webapp/routes.py:29 msgid \u0026#34;Hello, world!\u0026#34; msgstr \u0026#34;\u0026#34; üìù Note: After the header, the first line begins with msgid is the original text extracted by _() or _l(), the second line begins with msgstr is the translation.\nWe can translate the texts in the messages.po file to the languages we want to translate to. We can do it manually or using the translation editor like poedit.\nCompile the translations When our translation work is done, we need to compile the translation for use:\n(venv) $ pybabel compile -d webapp/translations compiling catalog webapp/translations/zh/LC_MESSAGES/messages.po to webapp/translations/zh/LC_MESSAGES/messages.mo This action will create the messages.mo file in the webapp/translations/zh/LC_MESSAGES directory.\nNow it\u0026rsquo;s time to test our translation work. One way is to adjust the language preference in the browser. For example, if we want to translate the website into Chinese, we can set the language preference to Simplified Chinese (zh-CN) in the browser\u0026rsquo;s language settings.\nThe other way is to force the language by making the localeselector function return the language we want to translate to. In the __init__.py file, make a change:\n@babel.localeselector def get_locale(): # return request.accept_languages.best_match(app.config[\u0026#39;LANGUAGES\u0026#39;]) return \u0026#39;zh_CN\u0026#39; Restart the server and we will see the website in Chinese.\nUpdating the translations If the website has changed or we want to update the translations, we can use the pybabel to update:\nFirst, we need to re-extract the messages.pot file and then use the pybabel update to update the translations. This update process is kind of intelligent merge, only the changes will be updated.\n(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot . (venv) $ pybabel update -i messages.pot -d webapp/translations Now we can exam the messages.po file in the webapp/translations/zh/LC_MESSAGES directory to edit the translations. After we finish the editing, we can compile the translations:\n(venv) $ pybabel compile -d webapp/translations Let the users decide the language The flask app has user login feature so we decided to let the users can decide the language they want to use after they logged in, if they don\u0026rsquo;t like the language that the browser locale chosed for them.\nThe language that the user selected will be stored in the session dictionary. So we will first check if the session['language'] is set. If it is, I will use it. Otherwise, we can use the browser locale.\nSo in the __init__.py file, make a change:\n@babel.localeselector def get_locale(): try: language = session[\u0026#39;language\u0026#39;] except KeyError: language = None if language is not None: return language else: return request.accept_languages.best_match(app.config[\u0026#39;LANGUAGES\u0026#39;]) Then in the routes.py file, add a new route:\n@app.route(\u0026#34;/language/\u0026lt;language\u0026gt;\u0026#34;) def set_language(language): session[\u0026#34;language\u0026#34;] = language return redirect(request.referrer or url_for(\u0026#34;index\u0026#34;)) üìù Note: Very straight forward, get the language from the URL and set it to the session. Then redirect to the page that the user came from or to the index page if the user didn\u0026rsquo;t come from any page. Please note that if the user logged out, the session will be cleared and the language will be set to the browser locale next time the user visit the website.\n","permalink":"https://blog.mindsmining.com/posts/how-to-make-a-flask-python-multiligual-website/","summary":"A brief summary of how to build a multilingual Flask Python website.","title":"Make a Flask Python Website Multilingual"},{"content":"Recently I\u0026rsquo;m working on build my own tech blog so I did some google search trying to find a \u0026ldquo;morden\u0026rdquo; way to build it. (I have been using Wordpress for some blogs and websites before.) The finnal two are Jekyll and Hugo, which are both Static Site generators with a lot of adoptions. After reading some articales about the comparison and the documentation of these two, I decided to try to build my own blog using Hugo and GitHub Actions.\nPrerequisites GitHub Account: Need to have a GitHub account to be able to push the blog to Github repository. Free account is enough. Git: Need to have Git installed on our machine. Step 1 - Build the website using Hugo Locally First of all, we need to build the website using Hugo locally or at least has go throuth the Quickstart guide\nStep 1.1 - Install Hugo According to the OS, we can install Hugo perspectively. For now we are using MacOS:\nbrew install hugo Check the version of Hugo:\nhugo version The output should be:\nhugo v0.92.0+extended darwin/amd64 BuildDate=unknown Step 1.2 - Create a new Hugo site, install a theme Hugo provides a lot of theme to choose from. We are using PaperMod theme, which is responsive and minimal. We also can choose a theme from the Hugo Themes.\nFirst create a new hugo site:\nhugo new site \u0026lt;our sitename\u0026gt; Then install the PaperMod theme:\ncd \u0026lt;our sitename\u0026gt; git init git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 üìù Note: We can choose to install the themes using Git Clone: git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 or choose to install the theme by downloading the zip file: Master Branch (Latest) and extract in the theme folder.\nModify the config.yaml file to add the theme:\ntheme = \u0026#34;PaperMod\u0026#34; üìù Note: Hugo support 3 types of config file: config.toml, config.yaml and config.json. We can use one of them as we like. For further refernce, Configure Hugo\nStep 1.3 - Add a post Then add a post:\nhugo new posts/\u0026lt;our post name\u0026gt;.md Add the contents of the post, it should start with the following:\n--- title: \u0026#34;\u0026lt;our post name\u0026gt;\u0026#34; date: 2022-01-19T23:05:28-08:00 draft: true --- To test the post locally, we need to start a hugo server and publish our post:\nhugo server -D This will start a hugo server and publish the website and then we can visit the site in our browser via the URL: http://localhost:1313/.\nüìù Note: The -D flag is used to build the site with content marked as draft. If we have finished draft the post and want to publish it to the site, we need to remove the draft: true or change it to draft: false in \u0026lt;our post name\u0026gt;.md. For more usage, please check the Basic Usage\nAfter testing the site, now we are ready to dploy the website to our Github repository and Github Pages.\nStep 2 - Build the website on GitHub Pages using GitHub Actions According to GitHub Docs, we can build a user/orgnization site or a project site on GitHub Pages. As for now we would like to build a user site for our personal blog.\nAnd according to GitHub Actions for GitHub Pages, the default config is to use the master branch as the source branch to hold the hugo files and to use the gh-pages branch as the destination branch to hold the published website, both are in the same repository.\nBut it\u0026rsquo;s more simple and error avoiding to use a private repository for the source (the hugo files) and a public repository for the published website, for the following reasons:\nKeep the hugo source files in a private repository; Avoid the error that will be caused with the GITHUB_TOKEN because for the first time of building the site, it will use the master branch to host the site, so we need to config it to use the gh-pages branch manually. For futher infomation, refer to First Deployment with GITHUB_TOKEN. So let\u0026rsquo;s create some new repositories on GitHub:\nStep 2.1 - Create new GitHub repositories Create a new private repository for the Hugo files, with a name that we like: ourhugosourcecode.\nAnd create a new public repository for the website, with a name in format: \u0026lt;githubusername\u0026gt;.github.io.\nLeave theses repositories empty.\nStep 2.2 - Configure Github Tokes for GitHub Actions Now let\u0026rsquo;s set up the personal_token:\nIn our GitHub Settings -\u0026gt; Developer settings -\u0026gt; Personal access tokens, click Generate new token:\nSelect the repo scope:\nThen generate the token and copy the token to our clipboard.\nIn the private ourhugosourcecode repositoty Settings -\u0026gt; Secrets, click New repository secret:\nadd the Personal access token we just generated (in clipboard) as serect value and set the name PERSONAL_TOKEN:\nStep 2.3 - Setup GitHub Workflow Add our workflow file .github/workflows/gh-pages.yml to our local repository with following contents:\nname: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # The personal token for the GitHub Actions external_repository: \u0026lt;githubusername\u0026gt;/\u0026lt;githubusername\u0026gt;.github.io # The external repository to deploy publish_dir: ./public # The directory to deploy, default is public folder full_commit_message: ${{ github.event.head_commit.message }} # cname: \u0026lt;our custom domain\u0026gt; üìù Note: The full_commit_message is used to set the commit message when we push to the master branch, by using this setting, we can use the commit message from the push event in the public repo and avoid the ugly commit message with / that system will use. The cname is used to set the CNAME file for the website, if we don\u0026rsquo;t use a custome domain for our website, we need to comment out this line.\nStep 2.4 - Configure baseURL Because the github pages will use the url \u0026lt;githubusername\u0026gt;.github.io, so we need to set the baseURL in the config.yaml file:\nbaseURL: \u0026#34;https://\u0026lt;githubusername\u0026gt;.github.io\u0026#34; Step 2.5 - Deploy the website Now push the repository to the master branch and GitHub Actions will deploy the website automatically.\nWe can check the process at 2 locations:\nIn hugo source file private repo, click the Actions, we will see the github pages workflow successfully deployed: In \u0026lt;githubusername\u0026gt;/\u0026lt;githubusername\u0026gt;.github.io public repo, click the Actions, we will see the github pages workflow successfully deployed: Step 2.6 - Check the website Now we can visit the website in the browser via the URL: http://\u0026lt;githubusername\u0026gt;.github.io/.\nStep 2.7 - Continue add more posts From now on, we can add more posts to the website. As soon as we test locally the website, we can push the repository to the ourhugosourcecode repo and GitHub Actions will deploy the website automatically.\nOptional - Using a custom domain GitHub Pages comes with a URL like \u0026lt;githubusername\u0026gt;.github.io, but we can also use a custom domain. To achive this, please refer to the Google Pages documentation: Configuring a custom domain.\nWhat need to be mentioned here is that although after successfully setup a custom domain for the website, by which Google will automatically create a CNAME file for the website in our public repository root, with the custom domain we set, after doing any update by pushing to this repository, the file will be deleted by the push. So we need to add a line to our gh-pages.yaml file to set the cname, after this modification the config.yaml file will be:\nname: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # The personal token for the GitHub Actions external_repository: \u0026lt;githubusername\u0026gt;/\u0026lt;githubusername\u0026gt;.github.io # The external repository to deploy publish_dir: ./public # The directory to deploy, default is public folder full_commit_message: ${{ github.event.head_commit.message }} cname: \u0026lt;our custom domain\u0026gt; # The custom domain we set This will create a CNAME file by GitHub Actions for the website in our public repository root everytime we do a push, and the custom domain will be used to access the website.\nAnd also at the same time we need to change the baseURL in the config.yaml file from \u0026lt;githubusername\u0026gt;.github.io to the custom domain, after this config the current config.yaml file should looks like this:\nbaseURL: \u0026#34;https://\u0026lt;our custom domain\u0026gt;/\u0026#34; title: \u0026lt;our website title\u0026gt; theme: PaperMod Epilogue Fianlly our website is successfully deployed to GitHub Pages. But this is only the beginning, we can continue to add more posts to the website, and we can also deploy more and more features or try different themes to our website.\nHugo is so many powerful, hope we can find some useful features in it and add it to our website in the furture.\n","permalink":"https://blog.mindsmining.com/posts/how-to-build-static-website-using-hugo-github-actions/","summary":"A tutorial on how to build a static website using Hugo and GitHub Actions","title":"Build static website using Hugo and GitHub Actions"}]